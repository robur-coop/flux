<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Miou (docs.findlib-1.miou.Miou)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">docs</a> &#x00BB; <a href="../../index.html">findlib-1</a> &#x00BB; <a href="../index.html">miou</a> &#x00BB; Miou</nav><header class="odoc-preamble"><h1>Module <code><span>Miou</span></code></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#miou,-a-simple-scheduler-for-ocaml-5.">Miou, a simple scheduler for OCaml 5.</a><ul><li><a href="#basics.">Basics.</a><ul><li><a href="#effects.">Effects.</a></li><li><a href="#a-task-manager.">A task manager.</a></li><li><a href="#domains.">Domains.</a></li></ul></li><li><a href="#design.">Design.</a><ul><li><a href="#preemption-and-cooperation">Preemption and cooperation</a><ul><li><a href="#availability.">Availability.</a></li><li><a href="#cooperation-and-effects.">Cooperation and effects.</a></li><li><a href="#performance-and-events.">Performance and events.</a></li></ul></li><li><a href="#miou-and-the-system.">Miou and the system.</a><ul><li><a href="#suspension-points.">Suspension points.</a></li><li><a href="#the-select()-function.">The <code>select()</code> function.</a></li></ul></li><li><a href="#user-task-management.">User task management.</a><ul><li><a href="#rule-1,-await-for-all-your-tasks.">Rule 1, await for all your tasks.</a></li><li><a href="#rule_2">Rule 2, only await for direct children.</a></li><li><a href="#rule-3,-a-task-can-only-be-awaited-or-cancelled.">Rule 3, a task can only be awaited or cancelled.</a></li><li><a href="#rule-4,-a-task-only-finishes-after-its-children-have-finished.">Rule 4, a task only finishes after its children have finished.</a></li><li><a href="#background">Rule 5, background tasks.</a></li><li><a href="#rule-6,-a-parallel-task-will-never-appear-in-the-main-domain.">Rule 6, a parallel task will never appear in the main domain.</a></li><li><a href="#rule-7,-suspension-points-are-local-to-the-domain.">Rule 7, suspension points are local to the domain.</a></li></ul></li></ul></li><li><a href="#orphans">Daemon and orphan tasks.</a></li><li><a href="#launch-a-promise.">Launch a promise.</a></li><li><a href="#cancellation.">Cancellation.</a></li><li><a href="#system">System events.</a><ul><li><a href="#domains,-suspension-and-monitoring.">Domains, suspension and monitoring.</a></li><li><a href="#sleep-state.">Sleep state.</a></li><li><a href="#cancellation._2">Cancellation.</a></li><li><a href="#tutorial.">Tutorial.</a></li></ul></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="miou,-a-simple-scheduler-for-ocaml-5."><a href="#miou,-a-simple-scheduler-for-ocaml-5." class="anchor"></a>Miou, a simple scheduler for OCaml 5.</h2><p>Miou is a simple scheduler for OCaml 5 that uses effects. It allows you to launch tasks (functions) concurrently and/or in parallel, as well as offering your application high availability to system events.</p><h3 id="basics."><a href="#basics." class="anchor"></a>Basics.</h3><h4 id="effects."><a href="#effects." class="anchor"></a>Effects.</h4><p>Since OCaml 5, it has been possible to use effects. An effect allows you to suspend the execution of a function and <i>fall</i> into a handler which, depending on the effect, would perform a specific operation that would <i>continue</i> the suspended function with the result of the operation.</p><p>For example, a <code>Hello: unit Effect.t</code> effect can suspend using <a href="../../../stdlib/Stdlib/Effect/index.html#val-perform"><code>Effect.perform</code></a>. A pre-installed <i>handler</i> will then retrieve this effect, perform the operation (say, display <code>&quot;Hello&quot;</code>), and unsuspend the function with the result of the operation (here, <code>() : unit</code>).</p><pre class="language-ocaml"><code>  type _ Effect.t += Hello : unit Effect.t

  let handler =
    let retc = Fun.id in
    let exnc = raise in
    let effc : type c. c Effect.t -&gt; ((c, 'a) continuation -&gt; 'a) option =
      function
      | Hello -&gt; Some (fun k -&gt; continue k (print_endline &quot;Hello&quot;))
      | _ -&gt; None
    in
    { retc; exnc; effc }

  let my_function () = Effect.perform Hello; print_endline &quot;World&quot;
  let () = match_with my_function () handler</code></pre><p>To go back to familiar OCaml elements, an effect is like an exception in that it breaks the execution flow. The &quot;handler&quot; is the <code>with ...</code> part of a <code>try ... with ...</code> in OCaml, and its installation corresponds to the <code>try ...</code>. Finally, and this is the fundamental difference with exceptions, there is the <i>continuation</i> which allows us to return to the point where the effect was launched.</p><pre class="language-ocaml"><code>  exception Hello

  let my_function () = raise Hello; print_endline &quot;World&quot;
  let () = try my_function () with Hello k -&gt; print_endline &quot;Hello&quot;; k ()</code></pre><p>Miou defines several effects that allow the user to interact with Miou's &quot;task manager&quot;. Miou's effects manager is installed using <a href="#val-run"><code>run</code></a>. So, if you want to use Miou, you should always start with <a href="#val-run"><code>run</code></a>:</p><pre class="language-ocaml"><code>  val my_program : unit -&gt; unit

  let () = Miou.run my_program ()</code></pre><h4 id="a-task-manager."><a href="#a-task-manager." class="anchor"></a>A task manager.</h4><p>Miou is a task manager. In other words, it manages a list of to-do tasks (which you can add to with <a href="#val-async"><code>async</code></a>/<a href="#val-call"><code>call</code></a>) and allows the user to manage these tasks. When a task is created, Miou gives the user a representation of the task: a promise <a href="#type-t"><code>t</code></a>.</p><p>From this promise, the user can:</p><ol><li><a href="#val-await"><code>await</code></a> for the result of the task</li><li><a href="#val-cancel"><code>cancel</code></a> the task</li></ol><p>Here's an example where a list of tasks are initiated and awaited. Interaction (task creation and awaiting) with Miou takes place via effects. Miou manages the execution order of these tasks and attempts to finish them all in order to terminate your program.</p><pre class="language-ocaml"><code>  let digest filename =
    Miou.async @@ fun () -&gt; (filename, Digest.file filename)

  let my_program filenames =
    (* 1) we create a list of tasks *)
    let prms = List.map digest filenames in
    (* 2) Miou manages the execution of these tasks *)
    (* 3) we wait these tasks *)
    let results = List.map Miou.await_exn prms in
    (* 4) we print results *)
    List.iter
      (fun (filename, hash) -&gt;
        Format.printf &quot;%s: %s\n%!&quot; filename (Digest.to_hex hash))
      results

  let () = Miou.run @@ fun () -&gt; my_program [ &quot;file01.ml&quot;; &quot;file02.ml&quot; ]</code></pre><p>Miou suggests a <span class="xref-unresolved" title="scheduler">little exercise</span> to implement a task manager with effects. It explains the role of promises, creation and awaiting for a task (it does not, however, describe cancellation).</p><h4 id="domains."><a href="#domains." class="anchor"></a>Domains.</h4><p>Since OCaml 5, it has been possible to run functions in parallel. These functions run on a domain that has its own minor heap - so allocating small amounts of data doesn't require synchronization with other domains. Miou provides a <i>pool</i> of domains to which the user can assign tasks to run in parallel.</p><pre class="language-ocaml"><code>  # let dom = Stdlib.Domain.spawn my_parallel_computation ;;
  # Stdlib.Domain.join dom ;;</code></pre><p>For more details on parallelism and garbage collection, we recommend reading the OCaml manual.</p><p>Miou prepares the allocation of a certain number of domains in advance. These will be waiting for tasks. The <a href="#val-call"><code>call</code></a> function is used to assign a new task to one of these domains. The user can specify the number of domains Miou can allocate via the <code>domains</code> argument to the <a href="#val-run"><code>run</code></a> function. We recommend using <code>Domain.recommended_domain_count () - 1</code> domains.</p><h3 id="design."><a href="#design." class="anchor"></a>Design.</h3><p>After this brief introduction to the basics of Miou (i.e. the use of effects and domains and the definition of a task manager), Miou stands out from other schedulers through its design, which we'll describe here.</p><p>However, we need to define 3 terms that will be used throughout this description:</p><ul><li>a <i>task</i> is the smallest sequence of programmed instructions that can be managed by Miou. In concrete terms, it's an OCaml function.</li><li>a domain (see <a href="Domain/index.html"><code>Domain</code></a> is a resource representing a processor available to execute a task)</li><li>a <i>fiber</i> is a task that will run on a domain in cooperation with other tasks</li></ul><h4 id="preemption-and-cooperation"><a href="#preemption-and-cooperation" class="anchor"></a>Preemption and cooperation</h4><p>OCaml offers only a fundamentally cooperative model for executing these tasks. Indeed, there are no mechanisms in OCaml to force the suspension of a given task. However, a given task can suspend itself in order to cooperate with other tasks on a limited resource such as a particular domain.</p><p>Miou offers a way of creating tasks (see <a href="#val-async"><code>async</code></a>) that are more precisely called <i>fibers</i>. These fibers must cooperate with each other to share the domain on which they run. This means that a fiber should not have exclusive domain control when other fibers are waiting to be executed.</p><pre class="language-ocaml"><code>  # Miou.run @@ fun () -&gt;
    let rec pr str n =
      if n &gt;= 0 then
      begin Miou.yield (); (* cooperation *)
            print_endline str;
            pr str (pred n)
      end in
    let prm0 = Miou.async @@ fun () -&gt; pr &quot;Hello&quot; 1 in
    let prm1 = Miou.async @@ fun () -&gt; pr &quot;World&quot; 1 in
    Miou.await_exn prm0;
    Miou.await_exn prm1 ;;
  Hello
  World
  Hello
  World
  - : unit = ()</code></pre><p>This task cooperation is achieved by <a href="#val-yield"><code>yield</code></a>, which interrupts the current task to leave the domain to another waiting task.</p><p>The problem with cooperation is that it does not take into account the irruption of external elements such as system events. Miou's objective is to be able to <i>interrupt</i> your application as soon as these events occur: in other words, to <b>preempt</b> the interruption of your tasks when these events occur.</p><h5 id="availability."><a href="#availability." class="anchor"></a>Availability.</h5><p>If it's important for us to interrupt your application as soon as these events are received, it's to increase the availability of your application to handle these events.</p><p>Let's take the example of a task making a long calculation. If an event such as the arrival of a TCP/IP connection were to occur at the same time as the calculation, we would consider the latter to be more important than the completion of the calculation. So we'd like to interrupt the calculation so that your application can handle this event as a priority.</p><pre class="language-ocaml"><code>  let _, _ =
    Miou.run @@ fun () -&gt;
    let rec server () =
      let socket = accept () in
      let _ = Miou.call (handler socket) in
      server ()
    in
    let prm0 = Miou.async server in
    let prm1 = Miou.async my_long_computation in
    Miou.both prm0 prm1

  (* [my_long_computation] should have multiple cooperative points to let
     the other task (our [server]) to accept incoming TCP/IP connections. *)</code></pre><p>In other words, your application is &quot;more&quot; available to handle events than to perform the calculations requested. This approach becomes interesting for services (such as an HTTP server) where the availability to handle such events is more important than prioritizing the calculation requested by a client.</p><h5 id="cooperation-and-effects."><a href="#cooperation-and-effects." class="anchor"></a>Cooperation and effects.</h5><p>And therein lies the crux of the problem: how do you preempt in a fundamentally cooperative system?</p><p>If we want to be in the best position to manage system events, we need to <i>increase</i> the points of cooperation that the fibers can emit. This is how Miou came up with a fundamental rule: <b>an effect yields</b>.</p><p>All effects (those defined by Miou as well as those defined by the user) reorder task execution. During this reordering, Miou can collect the system events that have just occurred. The objective is to do this as often as possible!</p><h5 id="performance-and-events."><a href="#performance-and-events." class="anchor"></a>Performance and events.</h5><p>At this point, we need to make clear to our future users a crucial choice we made for Miou: we prefer a scheduler that's available for system events, rather than one that performs well in calculations.</p><p>Indeed, on the cooperation points presented above, Miou will systematically ask whether any system events have occurred. However, if your ambition is to do nothing but calculations, the latter will be <i>&quot;polluted&quot;</i> by these unnecessary points of cooperation. So, by default, Miou is <b>less</b> efficient than other schedulers.</p><h4 id="miou-and-the-system."><a href="#miou-and-the-system." class="anchor"></a>Miou and the system.</h4><p>One of Miou's objectives is to be used in a unikernel. As far as the latter is concerned, possible interactions can be very limited. So we decided to separate the scheduler (<a href="#"><code>Miou</code></a>) from interactions with the underlying system (<code>Miou_unix</code> for a UNIX system).</p><p>There is a way to do this:</p><ol><li>define suspensions that will only be released when certain events occur</li><li>Miou can collect these events and we can tell it which suspension should be &quot;unblocked&quot; according to the collection.</li></ol><h5 id="suspension-points."><a href="#suspension-points." class="anchor"></a>Suspension points.</h5><p>Miou offers a way of creating what we call a suspension point. This can be created from a value <a href="#type-syscall"><code>syscall</code></a> (with a unique identifier) that the user can keep. This suspension point can be &quot;unblocked&quot; if the <a href="#type-select"><code>select</code></a> function given to Miou (via <a href="#val-run"><code>run</code></a>) informs it of the &quot;continuation&quot; of this suspension.</p><p>Let's take <code>read()</code> as an example. This function, which interacts with the system, can &quot;block&quot; (for example, if you try to read from a socket). To avoid blocking (and leave it to the system), you can ask Miou to suspend just beforehand so that it can do other tasks, and inform Miou as soon as you know that this <code>read()</code> will not block.</p><pre class="language-ocaml"><code>  let global = Hashtbl.create 0x100

  let miou_read fd buf off len =
    let syscall = Miou.syscall () in
    Hashtbl.add global fd syscall;
    Miou.suspend syscall;
    Unix.read fd buf off len</code></pre><p>Here, we use a global table to remind us that the file-descriptor we're using is associated with a <a href="#type-syscall"><code>syscall</code></a> we've just created. The next objective is to define a <a href="#type-select"><code>select</code></a> function that will observe whether the added file-descriptor is ready to be read.</p><h5 id="the-select()-function."><a href="#the-select()-function." class="anchor"></a>The <code>select()</code> function.</h5><p>Miou lets you inject a function to observe system events. This should appear each time tasks are rescheduled, as explained above with regard to application availability. This function should return any suspension points that can be unblocked.</p><pre class="language-ocaml"><code>  let select ~poll:_ _cancelled_points =
    let fds = Hashtbl.to_seq_keys global |&gt; List.of_seq in
    match Unix.select fds [] [] 0.1 with
    | fds, _, _ -&gt;
        let signals =
          List.map
            (fun fd -&gt;
              let syscall = Hashtbl.find global fd in
              let signal = Miou.signal syscall in
              Hashtbl.remove global fd; signal)
            fds
        in
        signals

  let run fn =
    let events _domain = { Miou.select; interrupt= Fun.const () } in
    Miou.run ~events fn</code></pre><p>As you can see, the next step is to produce a <a href="#val-run"><code>run</code></a> function that uses our <code>select</code>. This is what <code>Miou_unix</code> proposes for the example. However, there are a number of unresolved issues:</p><ol><li>in particular, the cancellation of a task and its suspension point</li><li>or the ability to wait only for system events</li><li>or the ability to interrupt such an observation</li></ol><p>We recommend reading the chapter on <a href="#system" title="system">system events</a> and its tutorial on <code>sleepers</code>.</p><h4 id="user-task-management."><a href="#user-task-management." class="anchor"></a>User task management.</h4><p>Users can manipulate their tasks via their <i>promises</i> (see <a href="#type-t"><code>t</code></a>). A promise is an OCaml value representing the task. It can be used to <a href="#val-await"><code>await</code></a> for or <a href="#val-cancel"><code>cancel</code></a> a task. However, certain rules apply to its use.</p><h5 id="rule-1,-await-for-all-your-tasks."><a href="#rule-1,-await-for-all-your-tasks." class="anchor"></a>Rule 1, await for all your tasks.</h5><p>It is forbidden to forget your children. The creation of a task necessarily implies that the developer <a href="#val-await"><code>await</code></a>s or <a href="#val-cancel"><code>cancel</code></a>s the task afterwards:</p><pre class="language-ocaml"><code>  # Miou.run @@ fun () -&gt; Miou.async (Fun.const ()) ;;
  Exception: Miou.Still_has_children.</code></pre><h5 id="rule_2"><a href="#rule_2" class="anchor"></a>Rule 2, only await for direct children.</h5><p>You can only await for your direct children. Transferring a promise to another task so that it can await for it is illegal:</p><pre class="language-ocaml"><code>  # Miou.run @@ fun () -&gt;
    let p = Miou.async (Fun.const ()) in
    let q = Miou.async (fun () -&gt; Miou.await_exn p) in
    Miou.await_all [ p; q ] |&gt; ignore
  Exception: Miou.Not_a_child.</code></pre><p>Task relationship clarifies what is involved in managing tasks and what they should transmit to each other. To answer this question, users will have to find their own mechanisms (<a href="Mutex/index.html"><code>Mutex</code></a>, <a href="Condition/index.html"><code>Condition</code></a>, <i>ipc</i>, etc.) to share results between tasks that are not directly related.</p><h5 id="rule-3,-a-task-can-only-be-awaited-or-cancelled."><a href="#rule-3,-a-task-can-only-be-awaited-or-cancelled." class="anchor"></a>Rule 3, a task can only be awaited or cancelled.</h5><p>Miou only allows you to await for or cancel a task. It is also impossible to detach a task. For more information on this subject, we recommend reading the <a href="#orphans" title="orphans">Daemon and orphan tasks.</a> section and our following rule: <a href="#background" title="background">background tasks</a>.</p><h5 id="rule-4,-a-task-only-finishes-after-its-children-have-finished."><a href="#rule-4,-a-task-only-finishes-after-its-children-have-finished." class="anchor"></a>Rule 4, a task only finishes after its children have finished.</h5><p>By extension, as soon as a task is finished, all its children are finished too. The same applies to cancellation. If you cancel a task, you also cancel its children.</p><h5 id="background"><a href="#background" class="anchor"></a>Rule 5, background tasks.</h5><p>There is, however, a <i>pattern</i> in which we'd like to put a task aside: in other words, forget about it for a while. Miou offers a specific API for this pattern, described <a href="#orphans" title="orphans">here</a>.</p><h5 id="rule-6,-a-parallel-task-will-never-appear-in-the-main-domain."><a href="#rule-6,-a-parallel-task-will-never-appear-in-the-main-domain." class="anchor"></a>Rule 6, a parallel task will never appear in the main domain.</h5><p>There may be a <i>contention</i> problem if you involve <code>dom0</code> in the tasks to be run in parallel. There may in fact be a situation where <code>dom0</code> is awaiting for <code>dom1</code>, which is awaiting for <code>dom0</code>.</p><p>Miou does not allow <code>dom0</code> to be assigned a parallel task. These assertions in the code below are true all the time.</p><pre class="language-ocaml"><code>  # Miou.run @@ fun () -&gt;
    let prm1 = Miou.call @@ fun () -&gt;
      let prm2 = Miou.call @@ fun () -&gt;
        Miou.Domain.self () in
      Miou.await_exn prm2, Miou.Domain.self () in
    let u, v = Miou.await_exn prm1 in
    assert (Miou.Domain.Uid.to_int u &lt;&gt; 0);
    assert (Miou.Domain.Uid.to_int v &lt;&gt; 0);
    assert (u &lt;&gt; v);;
  - : unit = ()</code></pre><p>However, you can involve <code>dom0</code> in the calculations with <a href="#val-async"><code>async</code></a>.</p><pre class="language-ocaml"><code>  let () =
    Miou.run ~domains:3 @@ fun () -&gt;
    let prm = Miou.async server in
    Miou.parallel server (List.init 3 (Fun.const ()))
    |&gt; List.iter (function Ok () -&gt; () | Error exn -&gt; raise exn);
    Miou.await_exn prm</code></pre><p>The above rule also limits the use of <a href="#val-call"><code>call</code></a> if you only have (or want) less than 2 domains. In fact, if you only have one domain, <a href="#val-call"><code>call</code></a> cannot launch tasks in parallel. In the situation where you only have 1 domains, it is possible to launch a task in parallel from <code>dom0</code> but it is impossible to launch a task in parallel from this <code>dom1</code>.</p><p>In both cases and in such a situation, an exception is thrown: <a href="#exception-No_domain_available"><code>No_domain_available</code></a>.</p><h5 id="rule-7,-suspension-points-are-local-to-the-domain."><a href="#rule-7,-suspension-points-are-local-to-the-domain." class="anchor"></a>Rule 7, suspension points are local to the domain.</h5><p>A suspension point is local to the domain. This means that only the domain in which it was created can unlock it. The <a href="#type-events"><code>events</code></a> value is created for each domain created by Miou.</p><p>The advantage of making suspension points local to domains is that the domain is solely responsible for these points and there are no inter-domain transfer mechanisms for managing system events. For the example, <a href="../../../stdlib/Stdlib/Domain/DLS/index.html"><code>Stdlib.Domain.DLS</code></a> can be used for a table of current events in each domain.</p><pre class="language-ocaml"><code>  let get, set =
    let make () = Hashtbl.create () in
    let dom = Stdlib.Domain.DLS.new_key make in
    let get () = Stdlib.Domain.DLS.get dom in
    let set value = Stdlib.Domain.DLS.set dom value in
    (get, set)

  let miou_read fd buf off len =
    let syscall = Miou.syscall () in
    let tbl = get () in
    Hashtbl.add tbl fd syscall;
    set tbl;
    Miou.suspend syscall;
    Unix.read fd buf off len</code></pre><div class="odoc-spec"><div class="spec module anchored" id="module-Pqueue"><a href="#module-Pqueue" class="anchor"></a><code><span><span class="keyword">module</span> Pqueue</span><span> = <a href="../Miou_pqueue/index.html">Miou_pqueue</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Logs"><a href="#module-Logs" class="anchor"></a><code><span><span class="keyword">module</span> Logs</span><span> = <a href="../Miou_logs/index.html">Miou_logs</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Fmt"><a href="#module-Fmt" class="anchor"></a><code><span><span class="keyword">module</span> Fmt</span><span> = <a href="../Miou_fmt/index.html">Miou_fmt</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Trigger"><a href="#module-Trigger" class="anchor"></a><code><span><span class="keyword">module</span> Trigger</span><span> = <a href="../sync/Miou_sync/Trigger/index.html">Miou_sync.Trigger</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Computation"><a href="#module-Computation" class="anchor"></a><code><span><span class="keyword">module</span> Computation</span><span> = <a href="../sync/Miou_sync/Computation/index.html">Miou_sync.Computation</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Queue"><a href="#module-Queue" class="anchor"></a><code><span><span class="keyword">module</span> Queue</span><span> = <a href="../Miou_queue/index.html">Miou_queue</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Backoff"><a href="#module-Backoff" class="anchor"></a><code><span><span class="keyword">module</span> Backoff</span><span> = <a href="../backoff/Miou_backoff/index.html">Miou_backoff</a></span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-reraise"><a href="#val-reraise" class="anchor"></a><code><span><span class="keyword">val</span> reraise : <span>exn <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>reraise exn</code> raises the exception <code>exn</code>. Unlike <code>raise exn</code>, <code>reraise exn</code> preserves the existing exception backtrace and even adds a &quot;Re-raised at&quot; entry with the call location.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Sequence"><a href="#module-Sequence" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Sequence/index.html">Sequence</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Domain"><a href="#module-Domain" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Domain/index.html">Domain</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Promise"><a href="#module-Promise" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Promise/index.html">Promise</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-No_domain_available"><a href="#exception-No_domain_available" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">No_domain_available</span></span></code></div><div class="spec-doc"><p>An exception which can be raised by <a href="#val-call"><code>call</code></a> if no domain is available to execute the task in parallel.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Ownership"><a href="#module-Ownership" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Ownership/index.html">Ownership</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="orphans"><a href="#orphans" class="anchor"></a>Daemon and orphan tasks.</h3><p>The prerogative of absolutely awaiting all of its direct children limits the user to considering certain anti-patterns. The best known is the <i>background</i> task: it consists of running a task that we would like to <i>detach</i> from the main task so that it can continue its life in autonomy. For OCaml/<code>lwt</code> aficionados, this corresponds to <code>Lwt.async</code>:</p><pre class="language-ocaml"><code>  val detach : (unit -&gt; unit t) -&gt; unit</code></pre><p>Not that we want to impose an authoritarian family approach between parent and children, but the fact remains that these <i>orphaned</i> tasks have resources that we need to manage and free-up (even in an abnormal situation). We consider detachment to be an <i>anti-pattern</i>, since it requires the developer to take particular care (compared to other promises) not to 'forget' resources that could lead to memory leaks.</p><p>Instead of letting the developer commit to using a function that might be problematic, Miou offers a completely different interface that consists of assisting the developer in a coherent (and consistent) approach to responding to a particular design that is not all that systematic.</p><p>So a promise can be associated with an <a href="#type-orphans"><code>orphans</code></a>. The latter will then collect the results of the associated promise tasks and give you back the promises (via <a href="#val-care"><code>care</code></a>) in a 'non-blocking' mode: applying <a href="#val-await"><code>await</code></a> to them will give you the results directly.</p><p>In this way, by creating promises associated with this <a href="#type-orphans"><code>orphans</code></a> value, we can at the same time &quot;clean up&quot; these <i>background</i> tasks, as this code shows:</p><pre class="language-ocaml"><code>  let rec clean_up orphans =
    match Miou.care orphans with
    | None | Some None -&gt; ()
    | Some (Some prm) -&gt; Miou.await_exn prm; clean_up orphans

  let rec server orphans =
    clean_up orphans;
    ignore (Miou.call ~orphans handler);
    server orphans

  let () = Miou.run @@ fun () -&gt; server (Miou.orphans ())</code></pre><p>There is a step-by-step <span class="xref-unresolved" title="echo">tutorial</span> on how to create an echo server and how to create a <i>daemon</i> with Miou.</p><div class="odoc-spec"><div class="spec type anchored" id="type-orphans"><a href="#type-orphans" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a orphans</span></span></code></div><div class="spec-doc"><p>The type of orphan collectors.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-orphans"><a href="#val-orphans" class="anchor"></a><code><span><span class="keyword">val</span> orphans : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span></span></code></div><div class="spec-doc"><p><code>orphans ()</code> makes a new orphan collectors which can used by <a href="#val-call"><code>call</code></a> and <a href="#val-async"><code>async</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-care"><a href="#val-care" class="anchor"></a><code><span><span class="keyword">val</span> care : <span><span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> option</span> option</span></span></code></div><div class="spec-doc"><p><code>care orphans</code> returns a <i>ready-to-await</i> promise or <code>Some None</code>. The user must <i>consume</i> the result of the promise with <a href="#val-await"><code>await</code></a>. Otherwise, Miou will raises the uncatchable <code>Still_has_children</code> exception. If <code>care</code> returns <code>None</code>, no children left behind, you can forget the <a href="#type-orphans"><code>orphans</code></a> value safely.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p><code>orphans</code> are necessarily attached to a promise, keeping the children of that promise in an orphanage. So, if <code>care</code> is used elsewhere than in the promise, an exception is raised to warn the user of a misuse of <code>care</code>. Indeed, the child returned by care can only be awaited (<a href="#val-await"><code>await</code></a>) by its direct parent (in reference to <a href="#rule_2" title="rule_2">our second rule</a>).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">_</span> <a href="#type-orphans">orphans</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length orphans</code> returns the number of remaining tasks.</p></div></div><h3 id="launch-a-promise."><a href="#launch-a-promise." class="anchor"></a>Launch a promise.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-async"><a href="#val-async" class="anchor"></a><code><span><span class="keyword">val</span> async : 
  <span><span class="optlabel">?give</span>:<span><a href="Ownership/index.html#type-t">Ownership.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?orphans</span>:<span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>async fn</code> (for Call with Current Continuation) returns a promise <a href="#type-t"><code>t</code></a> representing the state of the task given as an argument. The task will be executed <b>concurrently</b> with the other tasks in the current domain.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>a promise can only be attached to an orphan if the latter is owned by the parent promise. For the example, this code doesn't work because we're trying to attach 2 promises that don't have the same direct parent:</p></li></ul><pre class="language-ocaml"><code>  # Miou.run @@ fun () -&gt;
    let orphans = Miou.orphans () in
    let prm =
      Miou.async ~orphans @@ fun () -&gt;
      let prm = Miou.async ~orphans (Fun.const ()) in
      Miou.await_exn prm
    in
    Miou.await_exn prm ;;
  Exception: Invalid_argument &quot;The given orphans is owned by another promise&quot;.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-call"><a href="#val-call" class="anchor"></a><code><span><span class="keyword">val</span> call : 
  <span><span class="optlabel">?pin</span>:<a href="Domain/Uid/index.html#type-t">Domain.Uid.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?give</span>:<span><a href="Ownership/index.html#type-t">Ownership.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?orphans</span>:<span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>call fn</code> returns a promise <a href="#type-t"><code>t</code></a> representing the state of the task given as an argument. The task will be run in parallel: the domain used to run the task is different from the domain with the promise. This assertion is always true:</p><pre class="language-ocaml"><code>  let () =
    Miou.run @@ fun () -&gt;
    let p =
      Miou.call @@ fun () -&gt;
      let u = Miou.Domain.self () in
      let q = Miou.call @@ fun () -&gt; Miou.Domain.self () in
      (u, Miou.await_exn q)
    in
    let u, v = Miou.await_exn p in
    assert (v &lt;&gt; u)</code></pre><p>Sequential calls to <a href="#val-call"><code>call</code></a> do not guarantee that different domains are always chosen. This code <b>may</b> be true.</p><pre class="language-ocaml"><code>  let () =
    Miou.run @@ fun () -&gt;
    let p = Miou.call @@ fun () -&gt; Miou.Domain.self () in
    let q = Miou.call @@ fun () -&gt; Miou.Domain.self () in
    let u = Miou.await_exn p in
    let v = Miou.await_exn q in
    assert (u = v)</code></pre><p>To ensure that tasks are properly allocated to all domains, you need to use <a href="#val-parallel"><code>parallel</code></a>.</p><p><b>NOTE</b>: <a href="#val-call"><code>call</code></a> will never run a task on <i>dom0</i> (the main domain). Only the other domains can manage tasks in parallel.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-No_domain_available"><code>No_domain_available</code></a> <p>if no domain is available to execute the task in parallel or if the function is executed by the only domain available in parallel (it is impossible to assign a task to <code>dom0</code> from the other domains).</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>like <a href="#val-async"><code>async</code></a>, if the promise should be associated with an <code>orphan</code>, the orphan should be owned by the direct parent.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parallel"><a href="#val-parallel" class="anchor"></a><code><span><span class="keyword">val</span> parallel : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, exn)</span> <a href="../../../stdlib/Stdlib/index.html#type-result">result</a></span> list</span></span></code></div><div class="spec-doc"><p><code>parallel fn lst</code> is the <i>fork-join</i> model: it is a way of setting up and executing parallel tasks, such that execution branches off in parallel at designated points in the program, to &quot;join&quot; (merge) at a subsequent point and resume sequential execution.</p><p>Let's take the example of a sequential merge-sort:</p><pre class="language-ocaml"><code>  let sort ~compare (arr, lo, hi) =
    if hi - lo &gt;= 2 then begin
      let mi = (lo + hi) / 2 in
      sort ~compare (arr, lo, mi);
      sort ~compare (arr, mi, hi);
      merge ~compare arr lo mi hi
    end</code></pre><p>The 2 recursions work on 2 different spaces (from <code>lo</code> to <code>mi</code> and from <code>mi</code> to <code>hi</code>). We could parallelise their work such that:</p><pre class="language-ocaml"><code>  let sort ~compare (arr, lo, hi) =
    if hi - lo &gt;= 2 then begin
      let mi = (lo + hi) / 2 in
      ignore
        (Miou.parallel (sort ~compare) [ (arr, lo, mi); (arr, mi, hi) ]);
      merge ~compare arr lo mi hi
    end</code></pre><p>Note that <a href="#val-parallel"><code>parallel</code></a> launches tasks (<i>fork</i>) and awaits for them (<i>join</i>). Conceptually, this corresponds to a <a href="#val-call"><code>call</code></a> on each elements of the given list and a <a href="#val-await_all"><code>await_all</code></a> on all of them, with tasks allocated equally to the domains.</p><p><b>NOTE</b>: This function will never assign a task to <i>dom0</i> - only the other domains can run tasks in parallel. To involve <code>dom0</code>, it simply has to be the one that launches the parallelisation and performs the same task concurrently.</p><pre class="language-ocaml"><code>  val server : unit -&gt; unit

  let () =
    Miou.run ~domains:3 @@ fun () -&gt;
    let p = Miou.async server in
    Miou.parallel server (List.init 3 (Fun.const ()))
    |&gt; List.iter (function Ok () -&gt; () | Error exn -&gt; raise exn);
    Miou.await_exn p</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await"><a href="#val-await" class="anchor"></a><code><span><span class="keyword">val</span> await : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <a href="../../../stdlib/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>await prm</code> awaits for the task associated with the promise to finish. You can assume that after <a href="#val-await"><code>await</code></a>, the task has ended with an exception with the <code>Error</code> case or normally with the <code>Ok</code> case. In the case of an abnormal termination (the raising of an exception), the children of the promise are cancelled. For instance, this code is valid:</p><pre class="language-ocaml"><code>  # Miou_unix.run @@ fun () -&gt;
    let p = Miou.async @@ fun () -&gt;
      let child_of_p = Miou.async @@ fun () -&gt; Miou_unix.sleep 10. in
      failwith &quot;p&quot;;
      Miou.await_exn child_of_p in
    Miou.await p ;;
  - (unit, exn) result = Error (Failure &quot;p&quot;)
  # (* [child_of_p] was cancelled and you don't sleep 10s. *)</code></pre><p>Note that you should <b>always</b> await for your children (it's illegal to forget your children), as in the example above (even if an exception occurs). If a task does not await for its children, an <i>uncatchable</i> exception is raised by Miou:</p><pre class="language-ocaml"><code>  # Miou.run @@ fun () -&gt;
    ignore (Miou.async (Fun.const ())) ;;
  Exception: Miou.Still_has_children.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_exn"><a href="#val-await_exn" class="anchor"></a><code><span><span class="keyword">val</span> await_exn : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>await_exn prm</code> is an alias for <a href="#val-await"><code>await</code></a> which reraises the exception in the <code>Error</code> case.</p><p><b>Note about exceptions.</b></p><p>OCaml can keep a &quot;backtrace&quot; of where the exception came from, and Miou tries to keep this backtrace as best it can using <a href="#val-reraise"><code>reraise</code></a> (rather than <a href="../../../stdlib/Stdlib/index.html#val-raise"><code>raise</code></a>). However, it should be noted that in <i>simple</i> examples, the backtrace may not correspond to all the functions involved in raising the exception.</p><p>This is because OCaml may choose to inline certain functions (and, as a result, not mention them in the backtrace).</p><p>If you encounter problems with the backtrace, you can apply a pattern such as:</p><pre class="language-ocaml"><code>  let[@inline never] my_exception () = raise My_exception
  let foo ... =
    if ...
    then my_exception ()
    else ...</code></pre><p>It should be noted that if you use <a href="#val-await"><code>await</code></a> instead of <a href="#val-await_exn"><code>await_exn</code></a>, you lose the backtrace in the first case (since the exception is returned as a value rather than raised).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_one"><a href="#val-await_one" class="anchor"></a><code><span><span class="keyword">val</span> await_one : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <a href="../../../stdlib/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>await_one prms</code> awaits for a task to finish (by exception or normally). Despite <a href="#val-await_first"><code>await_first</code></a>, <a href="#val-await_one"><code>await_one</code></a> does <b>not</b> cancel all the others. The user must <a href="#val-await"><code>await</code></a> them then, otherwise Miou will assume they're still active and will raise <code>Still_has_children</code>.</p><pre class="language-ocaml"><code>  # Miou.run @@ fun () -&gt;
    Miou.await_one
      [ Miou.async (Fun.const 1)
      ; Miou.async (Fun.const 2) ] ;;
  Exception: Miou.Still_has_children</code></pre><p>A valid code would be:</p><pre class="language-ocaml"><code>  # Miou.run @@ fun () -&gt;
    let p = Miou.async (Fun.const 1) in
    let q = Miou.async (Fun.const 2) in
    match Miou.await_one [ p; q ] with
    | 1 -&gt; Miou.await_exn q
    | 2 -&gt; Miou.await_exn p
    | _ -&gt; assert false ;;
  - : int = 1</code></pre><p>If several tasks finish &quot;at the same time&quot; (as is the case in our example above), we prioritise the tasks that finished well and choose one at random.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if the promise list is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_first"><a href="#val-await_first" class="anchor"></a><code><span><span class="keyword">val</span> await_first : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <a href="../../../stdlib/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>await_first prms</code> awaits for a task to finish (by exception or normally) and cancels all the others. If several tasks finish &quot;at the same time&quot;, normally completed tasks are preferred to failed ones. This function can be useful for timeouts:</p><pre class="language-ocaml"><code>  # exception Timeout ;;
  # Miou_unix.run @@ fun () -&gt;
    let p0 = Miou.async (Fun.const ()) in
    let p1 = Miou.async @@ fun () -&gt; Miou_unix.sleep 2.; raise Timeout in
    Miou.await_first [ p0; p1 ] ;;
  - : (unit, exn) result = Ok ()</code></pre><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if the promise list is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_all"><a href="#val-await_all" class="anchor"></a><code><span><span class="keyword">val</span> await_all : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, exn)</span> <a href="../../../stdlib/Stdlib/index.html#type-result">result</a></span> list</span></span></code></div><div class="spec-doc"><p><code>await_all prms</code> awaits for all the tasks linked to the promises given. If one of the tasks raises an <i>uncatchable</i> exception, <a href="#val-await_all"><code>await_all</code></a> reraises the said exception. All tasks are awaited for, regardless of whether any fail.</p></div></div><h3 id="cancellation."><a href="#cancellation." class="anchor"></a>Cancellation.</h3><div class="odoc-spec"><div class="spec exception anchored" id="exception-Cancelled"><a href="#exception-Cancelled" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Cancelled</span></span></code></div><div class="spec-doc"><p>Used when a task is cancelled by <a href="#val-cancel"><code>cancel</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cancel"><a href="#val-cancel" class="anchor"></a><code><span><span class="keyword">val</span> cancel : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>cancel prm</code> <i>asynchronously</i> cancels the given promise <code>prm</code>. Miou allows the forgetting of a cancelled promise and the forgetting of its children. For instance, this code is valid (despite the second one):</p><pre class="language-ocaml"><code>  # Miou.run @@ fun () -&gt;
    ignore (Miou.cancel (Miou.call (Fun.const ()))) ;;
  - : unit = ()
  # Miou.run @@ fun () -&gt;
    ignore (Miou.call (Fun.const ())) ;;
  Exception: Miou.Still_has_children</code></pre><p>Cancellation terminates all the children. After the cancellation, the promise and its children all stopped. Resolved children are also cancelled (their results are erased). Canceling a task that has already been solved changes the state of the task to abnormal termination <code>Error Cancelled</code>.</p><pre class="language-ocaml"><code>  # Miou.run @@ fun () -&gt;
    let p = Miou.async (Fun.const ()) in
    Miou.await_exn p;
    Miou.cancel p;
    Miou.await_exn p ;;
  Exception: Miou.Cancelled.</code></pre><p>This case shows that, even if the task has been resolved internally, the cancellation also applies.</p><pre class="language-ocaml"><code>  # Miou.run @@ fun () -&gt;
    let p = Miou.async @@ fun () -&gt; print_endline &quot;Resolved!&quot; in
    Miou.yield ();
    Miou.cancel p;
    Miou.await_exn p ;;
  Resolved!
  Exception: Miou.Cancelled.</code></pre><p>Only the creator of a task can <a href="#val-cancel"><code>cancel</code></a> it (the relationship also applies to cancellation, otherwise Miou raises the exception <code>Not_a_child</code>).</p><p><b>NOTE</b>: Cancellation <i>asynchronicity</i> means that other concurrent tasks can run while the cancellation is in progress. In fact, in the case of an cancellation of a parallel task (see <a href="#val-call"><code>call</code></a>), the cancellation may take a certain amount of time (the time it takes for the domains to synchronise) which should not affect the opportunity for other concurrent tasks to run.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-yield"><a href="#val-yield" class="anchor"></a><code><span><span class="keyword">val</span> yield : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>yield ()</code> reschedules tasks and give an opportunity to carry out the tasks that have been on hold the longest. For instance:</p><pre class="language-ocaml"><code>  # Miou.run @@ fun () -&gt;
    let p = Miou.async @@ fun () -&gt; print_endline &quot;Hello&quot; in
    print_endline &quot;World&quot;;
    Miou.await_exn p ;;
  World
  Hello
  - : unit = ()
  # Miou.run @@ fun () -&gt;
    let p = Miou.async @@ fun () -&gt; print_endline &quot;Hello&quot; in
    Miou.yield ();
    print_endline &quot;World&quot;;
    Miou.await_exn p
  Hello
  World
  - : unit = ()</code></pre></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Hook"><a href="#module-Hook" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Hook/index.html">Hook</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="system"><a href="#system" class="anchor"></a>System events.</h3><p>Miou does not monitor system events. We arbitrarily leave this event monitoring to the user (so that Miou only requires OCaml to run). The advantage is that you can inject an event monitor from a specific system (such as a unikernel) if you want. However, <code>Miou_unix</code> is available if you want to do input/output.</p><p>To facilitate the integration of an event monitor, Miou offers an API for creating &quot;suspension points&quot; (see <a href="#val-suspend"><code>suspend</code></a>). In other words, points where execution will be blocked for as long as you wish. These points can be unblocked as soon as the monitor gives Miou a &quot;signal&quot; to these points with <a href="#val-signal"><code>signal</code></a>.</p><p>The user must specify a <a href="#type-select"><code>select</code></a> function (via the <a href="#val-run"><code>run</code></a> function and the <a href="#type-events"><code>events</code></a> type), which must correspond to system event monitoring (probably using <code>Unix.select</code>). From these events, the monitor can decide which suspension point (thanks to its <a href="#type-uid"><code>uid</code></a>) should be released. Miou will then call this function for each <i>quanta</i> consumed. This gives Miou a high degree of availability to consume and process system events.</p><h4 id="domains,-suspension-and-monitoring."><a href="#domains,-suspension-and-monitoring." class="anchor"></a>Domains, suspension and monitoring.</h4><p>Each domain has its own monitor so that the suspension and its continuation given by the monitor is always local to the domain (the domain managing the suspension is the only one allowed to execute the continuation). One <a href="#type-events"><code>events</code></a> is allocated per domain - it is given on which domain the <code>event</code> value is assigned. In this way, the values (such as a table of active file-descriptors) required to monitor system events need <b>not</b> be <i>domain-safe</i>.</p><h4 id="sleep-state."><a href="#sleep-state." class="anchor"></a>Sleep state.</h4><p>Sometimes, Miou only has suspension points. In other words, only system events are required to execute tasks (typically waiting for a TCP/IP connection). We say we're in a sleep state. In this case, Miou informs the monitor <code>select</code> that it can wait indefinitely (with <code>block:true</code>).</p><h4 id="cancellation._2"><a href="#cancellation._2" class="anchor"></a>Cancellation.</h4><p>It can happen that a task executed by one domain is cancelled by another domain (if the first was created by <a href="#val-call"><code>call</code></a>). This cancellation of a task can also mean the cancellation of existing suspension points into the task. Miou must therefore be able to <i>interrupt</i> a domain (especially if the latter is in a sleep state).</p><p>Thus, the user must have a mechanism for stopping event monitoring, which must be given to Miou via the <code>interrupt</code> field (see <a href="#type-events"><code>events</code></a>).</p><p>Finally, Miou informs the monitor of any points that have been cancelled, so that the associated events can no longer be monitored (this could involve cleaning up the table of active file-descriptors).</p><h4 id="tutorial."><a href="#tutorial." class="anchor"></a>Tutorial.</h4><p>To help you understand all these related elements, the distribution offers a short tutorial on how to implement functions that can block a given time (such as <code>Unix.sleep</code>): <code>sleepers</code>.</p><div class="odoc-spec"><div class="spec type anchored" id="type-syscall"><a href="#type-syscall" class="anchor"></a><code><span><span class="keyword">type</span> syscall</span></code></div><div class="spec-doc"><p>The type of <i>syscalls</i>.</p><p>A syscall is an unique ID and function executed as soon as the suspension point is released. This suspension point is created using the <a href="#val-suspend"><code>suspend</code></a> function.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-signal"><a href="#type-signal" class="anchor"></a><code><span><span class="keyword">type</span> signal</span></code></div><div class="spec-doc"><p>The type of signals.</p><p>A signal is a syscall that has been suspended (with <a href="#val-suspend"><code>suspend</code></a>) that we would like to resume. This is a value that must be given to Miou (via <code>select</code>) in order to <i>unblock</i> the previously created suspend point.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-uid"><a href="#type-uid" class="anchor"></a><code><span><span class="keyword">type</span> uid</span><span> = <span class="keyword">private</span> int</span></code></div><div class="spec-doc"><p>The type of unique IDs of <a href="#type-syscall"><code>syscall</code></a>s.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-syscall"><a href="#val-syscall" class="anchor"></a><code><span><span class="keyword">val</span> syscall : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-syscall">syscall</a></span></code></div><div class="spec-doc"><p><code>syscall ()</code> creates a <i>syscall</i> which permits the user to create a new suspension point via <a href="#val-suspend"><code>suspend</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-suspend"><a href="#val-suspend" class="anchor"></a><code><span><span class="keyword">val</span> suspend : <span><span class="optlabel">?fn</span>:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-syscall">syscall</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>suspend ?fn syscall</code> creates an user's defined suspension point. Miou will keep it internally and only the user is able to <i>resume</i> it via <a href="#type-events"><code>events</code></a> (and the <code>select</code> field) and a <a href="#type-signal"><code>signal</code></a>.</p><p>The suspension makes several checks, making the operation <i>non-atomic</i>. In other words, <code>suspend</code> can be cancelled <b>before</b> the suspension has been effectively added internally.</p><p>To keep Miou and the system's event management synchronized, the <code>suspend</code> function executes <code>fn</code> <b>only</b> when the suspension has been effectively added. Thus, for the user, the modification of the state managing system events should take place in the <code>fn</code> function (and not before or after <code>suspend</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-signal"><a href="#val-signal" class="anchor"></a><code><span><span class="keyword">val</span> signal : <span><a href="#type-syscall">syscall</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-signal">signal</a></span></code></div><div class="spec-doc"><p><code>signal syscall</code> creates a <a href="#type-signal"><code>signal</code></a> value which can be used by Miou to unblock the suspension point associated with the given syscall.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uid"><a href="#val-uid" class="anchor"></a><code><span><span class="keyword">val</span> uid : <span><a href="#type-syscall">syscall</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-uid">uid</a></span></code></div><div class="spec-doc"><p><code>uid syscall</code> returns the unique ID of the syscall.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-select"><a href="#type-select" class="anchor"></a><code><span><span class="keyword">type</span> select</span><span> = <span><span class="label">block</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-uid">uid</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-signal">signal</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-events"><a href="#type-events" class="anchor"></a><code><span><span class="keyword">type</span> events</span><span> = </span><span>{</span></code><ol><li id="type-events.select" class="def record field anchored"><a href="#type-events.select" class="anchor"></a><code><span>select : <a href="#type-select">select</a>;</span></code></li><li id="type-events.interrupt" class="def record field anchored"><a href="#type-events.interrupt" class="anchor"></a><code><span>interrupt : <span>unit <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-events.finaliser" class="def record field anchored"><a href="#type-events.finaliser" class="anchor"></a><code><span>finaliser : <span>unit <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : 
  <span><span class="optlabel">?quanta</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?g</span>:<a href="../../../stdlib/Stdlib/Random/State/index.html#type-t">Random.State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?domains</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?events</span>:<span>(<span><a href="Domain/Uid/index.html#type-t">Domain.Uid.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-events">events</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sys_signal"><a href="#val-sys_signal" class="anchor"></a><code><span><span class="keyword">val</span> sys_signal : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../stdlib/Stdlib/Sys/index.html#type-signal_behavior">Sys.signal_behavior</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../stdlib/Stdlib/Sys/index.html#type-signal_behavior">Sys.signal_behavior</a></span></code></div><div class="spec-doc"><p><code>signal signal behavior</code> attaches a <code>behavior</code> to a <code>signal</code>:</p><ul><li><code>Signal_default</code> aborts the program</li><li><code>Signal_ignore</code> ignore the signal</li><li><code>Signal_handle fn</code> calls <code>fn</code> (in the <code>dom0</code>)</li></ul><p><code>signal</code> is provided to be able to execute Miou's tasks when we receive a signal from the system. The <code>dom0</code> takes the responsibility to execute the given <code>fn</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-protect"><a href="#val-protect" class="anchor"></a><code><span><span class="keyword">val</span> protect : 
  <span><span class="label">on_cancellation</span>:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">finally</span>:<span>(<span><span class="label">cancelled</span>:bool <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>protect ~on_cancellation ~finally fn</code> invokes <code>fn ()</code> and then <code>finally ~cancelled</code> before <code>fn ()</code> returns its value or an exception as <a href="../../../stdlib/Stdlib/Fun/index.html#val-protect"><code>Fun.protect</code></a> or an cancellation. In the case of an abnormal termination, the exception is re-raised after <code>finally ~cancelled</code>. If <code>finally</code> raises an exception, then the exception <a href="../../../stdlib/Stdlib/Fun/index.html#exception-Finally_raised"><code>Fun.Finally_raised</code></a> is raised instead. In the case of a cancellation, it invokes <code>finally ()</code> and then <code>on_cancellation ()</code> before the deletion of <code>fn ()</code>. If <code>on_cancellation ()</code> raises an exception, then the &quot;uncatchable&quot; exception <code>On_cancellation_raised</code> is raised instead.</p><p><code>on_cancellation</code> must <b>not</b> use any effects. Using effects suspends execution and, in the case of cancellation, anything after the effect will never be executed.</p><p><code>finally</code> can use effects. <code>protect</code> informs the user if <code>finally</code> is invoked due to cancellation or not.</p><p><code>protect</code> can be used to enforce local invariants whether <code>fn ()</code> returns normally or raises an exception or is cancelled. However, it does not protect against unexpected exceptions raised inside <code>finally ~cancelled</code> and <code>on_cancellation ()</code> such as <a href="../../../stdlib/Stdlib/index.html#exception-Out_of_memory"><code>Stdlib.Out_of_memory</code></a>, <a href="../../../stdlib/Stdlib/index.html#exception-Stack_overflow"><code>Stdlib.Stack_overflow</code></a>, or asynchronous exceptions raised by signal handlers (e.g. <a href="../../../stdlib/Stdlib/Sys/index.html#exception-Break"><code>Sys.Break</code></a>).</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Mutex"><a href="#module-Mutex" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Mutex/index.html">Mutex</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Condition"><a href="#module-Condition" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Condition/index.html">Condition</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Lazy"><a href="#module-Lazy" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Lazy/index.html">Lazy</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>
