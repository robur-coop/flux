<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Flux (docs.local.flux.Flux)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">docs</a> &#x00BB; <a href="../../index.html">local</a> &#x00BB; <a href="../index.html">flux</a> &#x00BB; Flux</nav><header class="odoc-preamble"><h1>Module <code><span>Flux</span></code></h1><p>Flux is a library that provides an interface for manipulating streams with the Miou scheduler. We strongly recommend that you familiarise yourself with Miou and read our <a href="../flux.html" title="flux">tutorial</a>.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#sources">Sources.</a></li><li><a href="#sinks">Sinks.</a></li><li><a href="#flows">Flows.</a></li><li><a href="#streams">Streams.</a></li></ul></nav></div><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Bqueue"><a href="#module-Bqueue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Bqueue/index.html">Bqueue</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="sources"><a href="#sources" class="anchor"></a>Sources.</h2><p>Sources are decoupled producer of values.</p><p>Elements are pulled from a source when needed. A source can have an internal state that will be lazily initialized when (and if) a consumer requests elements. The internal state will be safety disposed when the source runs out of elements, when the consumer terminates, or if an exception is raised at any point in the streaming pipeline.</p><p>Sources are a great way to define decoupled producers that can be consumed with <a href="Stream/index.html#val-from"><code>Stream.from</code></a>. Sources are <i>single shot</i> and will have their input exhausted by most operations. Consider <a href="Sink/index.html#val-buffer" title="Sink.buffer">buffering</a> sources if you need to reuse their input.</p><p>The following example creates a source that counts down to zero:</p><pre class="language-ocaml"><code>  # let countdown n =
      let init () = n
      and pull = function
        | 0 -&gt; None
        | n -&gt; Some (n, n - 1)
      and stop = Fun.id in
      Flux.Source.Source { init; pull; stop }
  ;;
  # Stream.(from (countdown 3) |&gt; into Sink.sum) ;;
  - : int = 6</code></pre><div class="odoc-spec"><div class="spec type anchored" id="type-source"><a href="#type-source" class="anchor"></a><code><span><span class="keyword">type</span> <span>+'a source</span></span><span> = </span></code><ol><li id="type-source.Source" class="def variant constructor anchored"><a href="#type-source.Source" class="anchor"></a><code><span>| </span><span><span class="constructor">Source</span> : </span><span>{</span></code><ol><li id="type-source.init" class="def record field anchored"><a href="#type-source.init" class="anchor"></a><code><span>init : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'s</span>;</span></code></li><li id="type-source.pull" class="def record field anchored"><a href="#type-source.pull" class="anchor"></a><code><span>pull : <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'s</span>)</span> option</span>;</span></code></li><li id="type-source.stop" class="def record field anchored"><a href="#type-source.stop" class="anchor"></a><code><span>stop : <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-source">source</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Type of sources that produce elements of type <code>'a</code>.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Source"><a href="#module-Source" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Source/index.html">Source</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="sinks"><a href="#sinks" class="anchor"></a>Sinks.</h2><p>Sinks are decoupled consumer of values.</p><p>Sinks are streaming abstractions that consume values and produce an aggregated value as a result. The result value is extracted from an internal state that is built incrementally. The internal state can acquire resources that are guaranteed to be terminated when the sink is filled.</p><p>Sinks are a great way to define decoupled consumers that can be filled with <a href="Stream/index.html#val-into"><code>Stream.into</code></a>.</p><p>The following example demonstrates a sink that consumes all elements into a list:</p><pre class="language-ocaml"><code>  let list =
    let init () = []
    and push acc x = x :: acc
    and stop acc = List.rev acc
    and full _ = false in
    Flux.Stream.Sink { init; push; full; stop }</code></pre><p>Sinks are independent from sources and streams. You can think of them as packed arguments for folding functions with early termination.</p><div class="odoc-spec"><div class="spec type anchored" id="type-sink"><a href="#type-sink" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'r) sink</span></span><span> = </span></code><ol><li id="type-sink.Sink" class="def variant constructor anchored"><a href="#type-sink.Sink" class="anchor"></a><code><span>| </span><span><span class="constructor">Sink</span> : </span><span>{</span></code><ol><li id="type-sink.init" class="def record field anchored"><a href="#type-sink.init" class="anchor"></a><code><span>init : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'s</span>;</span></code></li><li id="type-sink.push" class="def record field anchored"><a href="#type-sink.push" class="anchor"></a><code><span>push : <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'s</span>;</span></code></li><li id="type-sink.full" class="def record field anchored"><a href="#type-sink.full" class="anchor"></a><code><span>full : <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code></li><li id="type-sink.stop" class="def record field anchored"><a href="#type-sink.stop" class="anchor"></a><code><span>stop : <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-sink">sink</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Types for sinks that consume elements of type <code>'a</code> and, once done, produce a value of type <code>'b</code>.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Sink"><a href="#module-Sink" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Sink/index.html">Sink</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="flows"><a href="#flows" class="anchor"></a>Flows.</h2><p>Flows are decoupled transformers of values.</p><p>Flows define streaming transformation, filtering or grouping operations that are fully disconnected from input and output. Their implementation intercepts an internal folding function and modifies the input one value at a time.</p><p>Flows are great way to define decoupled transformations that can be used with <a href="Stream/index.html#val-via"><code>Stream.via</code></a>.</p><p>A flow can be applied to a stream with <a href="Stream/index.html#val-via"><code>Stream.via</code></a>:</p><pre class="language-ocaml"><code>  # Stream.range 10 100
    |&gt; Stream.via (Flow.map (fun x -&gt; x + 1))
    |&gt; Stream.into Sink.sum
  - : int = 4995</code></pre><p>Flows can also be composed to form a pipeline:</p><pre class="language-ocaml"><code>  # let a = Flow.map (fun x -&gt; x + 1) in
    let b = Flow.filter (fun x -&gt; x mod 2 = 0) in
    Stream.range 10 100
    |&gt; Stream.via Flow.(a &gt;&gt; b)
    |&gt; Stream.into Sink.sum
  - : int = 2475</code></pre><div class="odoc-spec"><div class="spec type anchored" id="type-flow"><a href="#type-flow" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) flow</span></span><span> = </span><span>{</span></code><ol><li id="type-flow.flow" class="def record field anchored"><a href="#type-flow.flow" class="anchor"></a><code><span>flow : 'r. <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="#type-sink">sink</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-sink">sink</a></span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Stream transformers that consume values of type <code>'a</code> and produce values of type <code>'b</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-bstr"><a href="#type-bstr" class="anchor"></a><code><span><span class="keyword">type</span> bstr</span><span> =
  <span><span>(char, <a href="../../../stdlib/Stdlib/Bigarray/index.html#type-int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="../../../stdlib/Stdlib/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>)</span> <a href="../../../stdlib/Stdlib/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Flow"><a href="#module-Flow" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Flow/index.html">Flow</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="streams"><a href="#streams" class="anchor"></a>Streams.</h2><p>Streams combine sources, sinks and flows into a flexible streaming toolkit.</p><p>Stream is a purely functional abstraction for incremental, push-based, sequential processing of elements. Streams can be easily and efficiently transformed and concatenated.</p><p>Stream operations do not leak resources. This is guaranteed in the presence of early termination (when not all stream elements are consumed) or in case of exceptions in the streaming pipeline.</p><p>Streams are built to be compatible with <a href="#sources">sources</a>, <a href="#sinks">sinks</a> and <a href="#flows">flows</a>. To create a stream that produces all elements from a source use <a href="Stream/index.html#val-from"><code>Stream.from</code></a>. to consume a stream with a sink use <a href="Stream/index.html#val-into"><code>Stream.into</code></a> and to transform stream elements with a flow use <a href="Stream/index.html#val-via"><code>Stream.via</code></a>. For more sophisticated pipelines that might have source leftovers, <a href="Stream/index.html#val-run"><code>Stream.run</code></a> can be used.</p><div class="odoc-spec"><div class="spec type anchored" id="type-stream"><a href="#type-stream" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a stream</span></span><span> = </span><span>{</span></code><ol><li id="type-stream.stream" class="def record field anchored"><a href="#type-stream.stream" class="anchor"></a><code><span>stream : 'r. <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-sink">sink</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Type for streams with elements of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Stream"><a href="#module-Stream" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Stream/index.html">Stream</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>
